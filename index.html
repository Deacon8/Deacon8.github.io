<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deacon</title>
  </head>
  <style>
    body{ 
      background-color: #FBFCFC;
    }
    @font-face {
        font-family: 'Franklin';
        src: url('Franklin.ttf') format('truetype');
    }
    body{
      color: #1C2833;
      font-family: "Franklin", sans-serif;
    }
    h1{
      font-size: 3.5em;
    }
    a{
      color: #1C2833;
      font-size: 1.5em;

    }
    a:hover {
      color: #990000;
    }
    canvas {
      position: absolute; 
      left: 0; 
      right: 0; 
      margin-left: auto; 
      margin-right: auto; 
      z-index:-1;
}
  </style>
  <body>
    <canvas id="Cyclic" style="border:1px solid #000000;"></canvas>
  <h1>Hi,<br>I'm Deacon</h1>
  <h2>I study statistics at the University of British Columbia</h2>
  <a href="mailto:deaconsowerby8@gmail.com">Email</a>
    <br>
  <a href="https://github.com/Deacon8">Github</a>
    <br>
  <a href="https://www.linkedin.com/in/deacon-sowerby-804173231/">Linkedin</a>
    <br>
  <a href="Resume2023cs.pdf">Resume</a>
  </body>
  <script type="x-shader/x-vertex" id="vertex-shader">
    #version 100
    void main() {
      gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
      gl_PointSize = 800.;
    }
  </script>
  <script type="x-shader/x-fragment" id="fragment-shader">
      #version 100
      precision highp float;
  #define MAXSTEPS 100
  #define SURFACEDIST 0.01
  #define MAXDIST 100.

  float screenHeight = 600.;
  float screenWidth = 600.;
  uniform float iTime;

  mat4 RotateX(float theta) {
      float c = cos(theta);
      float s = sin(theta);

      return mat4(
          vec4(1, 0, 0, 0),
          vec4(0, c, -s, 0),
          vec4(0, s, c, 0),
          vec4(0, 0, 0, 1)
      );
  }
  mat4 RotateY(float theta) {
      float c = cos(theta);
      float s = sin(theta);

      return mat4(
          vec4(c, 0, s, 0),
          vec4(0, 1, 0, 0),
          vec4(-s, 0, c, 0),
          vec4(0, 0, 0, 1)
      );
  }
  float sdSphere(vec3 Point, float Radius)
  {
      vec3 Position = vec3(0, 1, 6);
      return length(Point - Position) - Radius;
  }
  float sdGyroid(vec3 p, float Scale, float thickness, float bias)
  {
      p*=Scale;
      return abs(dot(sin(p), cos(p.zxy))-bias)/Scale-thickness;
  }
  float sdPyramid( vec3 p, float h)
  {
    float m2 = h*h + 0.25;
      
    p.xz = abs(p.xz);
    p.xz = (p.z>p.x) ? p.zx : p.xz;
    p.xz -= 0.5;

    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);
    
    float s = max(-q.x,0.0);
    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );
      
    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;
    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);
      
    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);
      
    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));
  }
  float GetDist(vec3 Position)//Scene
  {
      float sphere = sdSphere(Position, 20. + sin(iTime*.1));
      float gyroid = sdGyroid(Position, 1., .03, 1.3);
      float g1 = sdGyroid(Position, 10.76, .03, .4);
      float g2= sdGyroid(Position, 20.76, .06, .5);
      float g3 = sdGyroid(Position, 30.76, .03, .6);
      gyroid -=g1*.4;
      gyroid -=g2*.3;
      gyroid -=g3*.2;
      
      float s = max(sphere, gyroid);
      //d = min(sdSphere(Position * 2., 2.), d);
      return s;
  }

  float RayMarch(vec3 RayOrigin, vec3 RayDirection)
  {
      float Dist = 0.;
      for(int i = 0; i < MAXSTEPS; i++)
      {
          vec3 Point = RayOrigin + Dist * RayDirection;
          float DistSphere = GetDist(Point);
          Dist+=DistSphere;
          if(DistSphere < SURFACEDIST || Dist > MAXDIST){break;}
      }
      return Dist;
  }

  vec3 GetNormal(vec3 p)
  {
      float Dist = GetDist(p);
      vec3 E = vec3(.01, 0., 1.);
      vec3 Normal = Dist - vec3(
      GetDist(p - E.xyy),
      GetDist(p - E.yxy),
      GetDist(p - E.yyx)
      );
      return normalize(Normal);
  }

  float GetLight(vec3 LightStuff)
  {
      vec3 LightPos = vec3(-20, 20, 6);
      //LightPos.xz += vec2(sin(iTime), cos(iTime))*2.;
      vec3 Light = normalize(LightPos - LightStuff);
      vec3 Normal = GetNormal(LightStuff);
      float Dif = dot(Normal, Light);
      float d = RayMarch(LightStuff+Normal*SURFACEDIST*2., Light);
      if(d<length(LightPos-LightStuff)) Dif *= .1;
      return Dif;
  }

  float Noise( vec2 p )
  {
      vec3 q = vec3( dot(p,vec2(127.1,311.7)), 
            dot(p,vec2(269.5,183.3)), 
            dot(p,vec2(419.2,371.9)) );
    return fract(sin(q)*43758.5453).x;
  }

  void main()
  {
      // Normalized pixel coordinates (from 0 to 1)
      vec2 uv = (gl_FragCoord.xy-.5*vec2(screenWidth, screenHeight))/screenHeight;

      //Origin Point
      vec3 RayOrigin = vec3(sin(iTime)*5.-10., cos(iTime)*5.-10., -60.+sin(iTime));
      
      vec3 RayDirection = normalize(vec3(uv.x, uv.y, 1.));
      float d = RayMarch(RayOrigin, RayDirection);
      
      vec3 col;
      if(d<MAXDIST) 
      {
          vec3 p = RayOrigin + RayDirection * d;
          float Diffuse = GetLight(p);
          col = vec3(Diffuse);
          //col += d/10.;
          //col += fract(GetNormal(p));
          col = pow(col, vec3(.2545));
          col = mix(col, vec3(sin(iTime), sin(-iTime), 0.), 0.4);
      }
      else if(Noise(uv) > 0.99)
      {
          col = vec3(1., 1., 1.) * fract(Noise(uv));
      }

      // Output to screen
      gl_FragColor = vec4(col,1.0);
  }
  </script>   
  <script>
    var gl, program;
    var canvas = document.querySelector("canvas");
    canvas.width = 800;
    canvas.height = 800;
    
    gl = canvas.getContext("webgl");
    gl.viewport(0, 0, 
    gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    var source = document.querySelector("#vertex-shader").innerHTML;
    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader,source);
    gl.compileShader(vertexShader);
    source = document.querySelector("#fragment-shader").innerHTML
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader,source);
    gl.compileShader(fragmentShader);
    program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.detachShader(program, vertexShader);
    gl.detachShader(program, fragmentShader);
    gl.deleteShader(vertexShader);
    gl.deleteShader(fragmentShader);
    gl.enableVertexAttribArray(0);
    buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.vertexAttribPointer(0, 1, gl.FLOAT, false, 0, 0);
    gl.useProgram(program);
    gl.drawArrays(gl.POINTS, 0, 1); 

    function draw()
    { 
      gl.uniform1f (gl.getUniformLocation(program, "iTime"), ((Date.now()%100))); 
      gl.useProgram(program);
      gl.drawArrays(gl.POINTS, 0, 1); 
    }
    setInterval(function(){ 
      draw();
    }, 250);

  </script>
</html>
